"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const babel_target_1 = require("./babel-target");
const blind_targeting_error_1 = require("./blind.targeting.error");
const excluded_packages_1 = require("./excluded.packages");
const babel_multi_target_loader_1 = require("./babel.multi.target.loader");
const plugin_name_1 = require("./plugin.name");
const NOT_TARGETED = [
    /\.s?css$/,
];
// picks up where BabelTargetEntryPlugin leaves off and takes care of targeting all dependent modules
// includes special case handling for Angular lazy routes
/**
 * @internalapi
 */
class TargetingPlugin {
    constructor(targets, exclude, doNotTarget, externals) {
        this.targets = targets;
        this.exclude = exclude;
        this.externals = externals;
        this.babelLoaderPath = require.resolve('babel-loader');
        this.babelLoaders = {};
        this.remainingTargets = {};
        this.doNotTarget = NOT_TARGETED.concat(doNotTarget || []);
    }
    apply(compiler) {
        // make sure our taps come after other plugins (particularly AngularCompilerPlugin)
        compiler.hooks.afterPlugins.tap(plugin_name_1.PLUGIN_NAME, () => {
            compiler.hooks.contextModuleFactory.tap(plugin_name_1.PLUGIN_NAME, (cmf) => {
                cmf.hooks.afterResolve.tapPromise(plugin_name_1.PLUGIN_NAME, this.targetLazyModules.bind(this));
            });
            compiler.hooks.normalModuleFactory.tap(plugin_name_1.PLUGIN_NAME, (nmf) => {
                nmf.hooks.module.tap(plugin_name_1.PLUGIN_NAME, this.targetModule.bind(this));
                nmf.hooks.afterResolve.tapPromise(plugin_name_1.PLUGIN_NAME, this.afterResolve.bind(this));
            });
            compiler.hooks.watchRun.tapPromise(plugin_name_1.PLUGIN_NAME, () => __awaiter(this, void 0, void 0, function* () {
                this.remainingTargets = {};
            }));
        });
    }
    // HACK ALERT!
    // Sometimes, there just isn't a way to trace a request back to a targeted module or entry. This happens with
    // Angular's lazy loaded routes and ES6 dynamic imports. With dynamic imports, we'll get a pair of requests for each
    // time a module is dynamically referenced. The best we can do is just fake it - create an array for each request
    // that has a copy of the targets array, and assign a the first remaining target to each request
    getBlindTarget(issuer, key) {
        if (!this.remainingTargets) {
            this.remainingTargets = {};
        }
        if (!this.remainingTargets[issuer]) {
            this.remainingTargets[issuer] = {};
        }
        if (!this.remainingTargets[issuer][key]) {
            this.remainingTargets[issuer][key] = this.targets.slice(0);
        }
        if (!this.remainingTargets[issuer][key].length) {
            throw new blind_targeting_error_1.BlindTargetingError(key);
        }
        return this.remainingTargets[issuer][key].shift();
    }
    targetLazyModules(resolveContext) {
        return __awaiter(this, void 0, void 0, function* () {
            // handle lazy modules from AngularCompilerPlugin
            if (resolveContext.mode === 'lazy' &&
                resolveContext.resource &&
                resolveContext.resource.endsWith('$$_lazy_route_resource')) {
                // FIXME: Mixing Harmony and CommonJs requires of @angular/core breaks lazy loading!
                // if this is happening, it's likely that a dependency has not correctly provided a true ES6 module and is
                // instead providing CommonJs module.
                const babelTarget = this.getBlindTarget(resolveContext.context, resolveContext.resource);
                resolveContext.resource = babelTarget.getTargetedRequest(resolveContext.resource);
                // track a map of resources to targets
                if (!resolveContext.resolveOptions.babelTargetMap) {
                    resolveContext.resolveOptions.babelTargetMap = {};
                }
                resolveContext.resolveOptions.babelTargetMap[resolveContext.resource] = babelTarget;
                // piggy-back on angular's resolveDependencies function to target the dependencies.
                const ogResolveDependencies = resolveContext.resolveDependencies;
                resolveContext.resolveDependencies = (_fs, _resource, cb) => {
                    ogResolveDependencies(_fs, _resource, (err, dependencies) => {
                        this.targetDependencies(babelTarget, { dependencies });
                        cb(null, dependencies);
                    });
                };
                this.targetDependencies(babelTarget, resolveContext);
                return resolveContext;
            }
        });
    }
    targetModule(module) {
        if (!this.isTargetedRequest(module, module.request)) {
            return;
        }
        const babelTarget = babel_target_1.BabelTarget.getTargetFromTag(module.request, this.targets);
        if (!babelTarget) {
            return;
        }
        module.request = babelTarget.getTargetedRequest(module.request);
        if (!module.options) {
            module.options = {};
        }
        module.options.babelTarget = babelTarget;
        const ogAddDependency = module.addDependency;
        module.addDependency = (dep) => {
            this.targetDependency(dep, babelTarget);
            return ogAddDependency.call(module, dep);
        };
    }
    targetDependency(dep, babelTarget) {
        if (!dep.request || !this.isTargetedRequest(dep, dep.request)) {
            return;
        }
        // update the dependency requests to be targeted
        // only tag dep.request, not tag dep.userRequest, it breaks lazy loading
        // userRequest basically maps the user-friendly name to the actual request
        // so if the code does require('some-lazy-route/lazy.module.ngfactory.js') <-- userRequest
        // it can be mapped to 'some-lazy-route/lazy.module.ngfactory.js?babelTarget=modern <-- request
        if (dep.request) {
            dep.request = babelTarget.getTargetedRequest(dep.request);
        }
    }
    targetDependencies(babelTarget, context) {
        context.dependencies.forEach((dep) => this.targetDependency(dep, babelTarget));
    }
    afterResolve(resolveContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const loaders = resolveContext.loaders
                .filter((loaderInfo) => loaderInfo.options && loaderInfo.options.isBabelMultiTargetLoader);
            this.checkResolveTarget(resolveContext, !!loaders.length);
            this.replaceLoaders(resolveContext, loaders);
        });
    }
    checkResolveTarget(resolveContext, hasLoader) {
        if (!this.isTargetedRequest(resolveContext, resolveContext.request) ||
            !this.isTranspiledRequest(resolveContext) ||
            !hasLoader) {
            return;
        }
        let babelTarget = babel_target_1.BabelTarget.getTargetFromTag(resolveContext.request, this.targets);
        if (babelTarget) {
            this.targetChunkNames(resolveContext, babelTarget);
            return;
        }
        babelTarget = this.getTargetFromContext(resolveContext);
        if (babelTarget) {
            // this is probably a dynamic import, in which case the dependencies need to get targeted
            resolveContext.dependencies.forEach((dep) => this.targetDependency(dep, babelTarget));
        }
        else {
            babelTarget = this.getBlindTarget(resolveContext.resourceResolveData.context.issuer, resolveContext.request);
        }
        this.targetChunkNames(resolveContext, babelTarget);
        resolveContext.request = babelTarget.getTargetedRequest(resolveContext.request);
        if (resolveContext.resource) {
            resolveContext.resource = babelTarget.getTargetedRequest(resolveContext.resource);
        }
    }
    targetChunkNames(resolveContext, babelTarget) {
        resolveContext.dependencies.forEach((dep) => {
            if (!dep.block || !dep.block.groupOptions || !dep.block.groupOptions.name) {
                return;
            }
            dep.block.groupOptions.name = babelTarget.getTargetedAssetName(dep.block.groupOptions.name);
        });
    }
    replaceLoaders(resolveContext, loaders) {
        const babelTarget = resolveContext.resourceResolveData &&
            this.isTranspiledRequest(resolveContext) &&
            this.getTargetFromContext(resolveContext);
        loaders.forEach((loader) => {
            const index = resolveContext.loaders.indexOf(loader);
            if (!babelTarget) {
                resolveContext.loaders.splice(index, 1);
                return;
            }
            const effectiveLoader = {
                loader: loader.loader,
                options: loader.options.loaderOptions,
                ident: loader.ident,
            };
            if (loader.loader === this.babelLoaderPath) {
                resolveContext.loaders.splice(index, 1, this.getTargetedBabelLoader(effectiveLoader, babelTarget));
            }
            else {
                resolveContext.loaders.splice(index, 1, effectiveLoader);
            }
        });
    }
    isTargetedRequest(context, request) {
        if (this.doNotTarget && this.doNotTarget.find(entry => entry.test(request))) {
            return false;
        }
        return !this.isExternalRequest(context, request, this.externals);
    }
    isExternalRequest(context, request, externals) {
        if (!externals) {
            return false;
        }
        if (Array.isArray(externals)) {
            for (const ext of externals) {
                if (this.isExternalRequest(context, request, ext)) {
                    return true;
                }
            }
            return false;
        }
        if (typeof (externals) === 'function') {
            throw new Error('Using an ExternalsFunctionElement is not supported');
        }
        if (typeof (externals) === 'string') {
            return request === externals;
        }
        if (externals instanceof RegExp) {
            return externals.test(request);
        }
        if (typeof (externals) === 'object') {
            return this.isExternalRequest(context, request, Object.keys(externals));
        }
        return false;
    }
    isTranspiledRequest(resolveContext) {
        // ignore files/libs that are known to not need transpiling
        if (excluded_packages_1.STANDARD_EXCLUDED.find(pattern => pattern.test(resolveContext.resource))) {
            // TODO: report this somewhere?
            // console.info('not transpiling request from STANDARD_EXCLUDED', resolveContext.resource);
            return false;
        }
        if (excluded_packages_1.KNOWN_EXCLUDED.find(pattern => pattern.test(resolveContext.resource))) {
            // TODO: report this somewhere?
            // console.info('not transpiling request from KNOWN_EXCLUDED', resolveContext.resource);
            return false;
        }
        if (this.exclude.find(pattern => pattern.test(resolveContext.resolve))) {
            // TODO: report this somewhere?
            // console.info('not transpiling request from excluded patterns', resolveContext.resource);
            return false;
        }
        const pkgRoot = resolveContext.resourceResolveData.descriptionFileRoot;
        const pkg = resolveContext.resourceResolveData.descriptionFileData;
        // coming from a package's "main" or "browser" field? don't need to transpile
        if (pkg.main && resolveContext.resource === path.resolve(pkgRoot, pkg.main)) {
            // TODO: report this somewhere?
            // console.info('not transpiling request using package "main"', resolveContext.resource);
            return false;
        }
        if (pkg.browser) {
            // TODO: report this somewhere?
            // console.info('not transpiling request using package "browser"', resolveContext.resource);
            if (typeof (pkg.browser) === 'string' && resolveContext.resource === path.resolve(pkgRoot, pkg.browser)) {
                return false;
            }
            if (Array.isArray(pkg.browser) &&
                pkg.browser.find((entry) => resolveContext.resource === path.resolve(pkgRoot, entry))) {
                return false;
            }
            if (typeof (pkg.browser === 'object') &&
                Object.values(pkg.browser).find((entry) => resolveContext.resource === path.resolve(pkgRoot, entry))) {
                return false;
            }
        }
        return true;
    }
    getTargetFromContext(context) {
        if (context.contextInfo && context.contextInfo.babelTarget) {
            return context.contextInfo.babelTarget;
        }
        if (context.resourceResolveData &&
            context.resourceResolveData.context &&
            context.resourceResolveData.context.babelTarget) {
            return context.resourceResolveData.context.babelTarget;
        }
        const dependencies = context.dependencies;
        for (const dep of dependencies) {
            if (dep.babelTarget) {
                return dep.babelTarget;
            }
            if (dep.originModule) {
                const target = babel_target_1.BabelTarget.findTarget(dep.originModule);
                if (target) {
                    return target;
                }
            }
        }
    }
    getTargetedBabelLoader(loader, babelTarget) {
        if (!this.babelLoaders[babelTarget.key]) {
            this.babelLoaders[babelTarget.key] = Object.assign({}, loader, {
                loader: this.babelLoaderPath,
                options: babelTarget.options,
            });
        }
        return this.babelLoaders[babelTarget.key];
    }
    static loader(loader) {
        return new babel_multi_target_loader_1.BabelMultiTargetLoader(loader);
    }
}
exports.TargetingPlugin = TargetingPlugin;
//# sourceMappingURL=targeting.plugin.js.map